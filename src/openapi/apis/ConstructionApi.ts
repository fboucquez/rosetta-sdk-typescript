/* tslint:disable */
/* eslint-disable */
/**
 * Rosetta
 * Build Once. Integrate Your Blockchain Everywhere.
 *
 * The version of the OpenAPI document: 1.4.10
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConstructionCombineRequest,
    ConstructionCombineRequestFromJSON,
    ConstructionCombineRequestToJSON,
    ConstructionCombineResponse,
    ConstructionCombineResponseFromJSON,
    ConstructionCombineResponseToJSON,
    ConstructionDeriveRequest,
    ConstructionDeriveRequestFromJSON,
    ConstructionDeriveRequestToJSON,
    ConstructionDeriveResponse,
    ConstructionDeriveResponseFromJSON,
    ConstructionDeriveResponseToJSON,
    ConstructionHashRequest,
    ConstructionHashRequestFromJSON,
    ConstructionHashRequestToJSON,
    ConstructionMetadataRequest,
    ConstructionMetadataRequestFromJSON,
    ConstructionMetadataRequestToJSON,
    ConstructionMetadataResponse,
    ConstructionMetadataResponseFromJSON,
    ConstructionMetadataResponseToJSON,
    ConstructionParseRequest,
    ConstructionParseRequestFromJSON,
    ConstructionParseRequestToJSON,
    ConstructionParseResponse,
    ConstructionParseResponseFromJSON,
    ConstructionParseResponseToJSON,
    ConstructionPayloadsRequest,
    ConstructionPayloadsRequestFromJSON,
    ConstructionPayloadsRequestToJSON,
    ConstructionPayloadsResponse,
    ConstructionPayloadsResponseFromJSON,
    ConstructionPayloadsResponseToJSON,
    ConstructionPreprocessRequest,
    ConstructionPreprocessRequestFromJSON,
    ConstructionPreprocessRequestToJSON,
    ConstructionPreprocessResponse,
    ConstructionPreprocessResponseFromJSON,
    ConstructionPreprocessResponseToJSON,
    ConstructionSubmitRequest,
    ConstructionSubmitRequestFromJSON,
    ConstructionSubmitRequestToJSON,
    TransactionIdentifierResponse,
    TransactionIdentifierResponseFromJSON,
    TransactionIdentifierResponseToJSON,
} from '../models';
import * as runtime from '../runtime';

export interface ConstructionCombineOperationRequest {
    constructionCombineRequest: ConstructionCombineRequest;
}

export interface ConstructionDeriveOperationRequest {
    constructionDeriveRequest: ConstructionDeriveRequest;
}

export interface ConstructionHashOperationRequest {
    constructionHashRequest: ConstructionHashRequest;
}

export interface ConstructionMetadataOperationRequest {
    constructionMetadataRequest: ConstructionMetadataRequest;
}

export interface ConstructionParseOperationRequest {
    constructionParseRequest: ConstructionParseRequest;
}

export interface ConstructionPayloadsOperationRequest {
    constructionPayloadsRequest: ConstructionPayloadsRequest;
}

export interface ConstructionPreprocessOperationRequest {
    constructionPreprocessRequest: ConstructionPreprocessRequest;
}

export interface ConstructionSubmitOperationRequest {
    constructionSubmitRequest: ConstructionSubmitRequest;
}

/**
 * ConstructionApi - controller interface for the server side implementation.
 *
 * @export
 * @interface ConstructionApiController
 */
export class ConstructionApiController<Req extends { body: any } = { body: any }> {
    /**
     *
     * @param service - The service that implements
     */
    constructor(private readonly service: ConstructionApiService) {}

    /**
     * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures. The signed transaction returned from this method will be sent to the `/construction/submit` endpoint by the caller.
     * Create Network Transaction from Signatures
     *
     *  @param req - The request object, where the body is a ConstructionCombineRequest
     */
    constructionCombine(req: Req): Promise<any> {
        return this.service.constructionCombine(ConstructionCombineRequestFromJSON(req.body)).then(ConstructionCombineResponseToJSON);
    }

    /**
     * Derive returns the AccountIdentifier associated with a public key. Blockchains that require an on-chain action to create an account should not implement this method.
     * Derive an AccountIdentifier from a PublicKey
     *
     *  @param req - The request object, where the body is a ConstructionDeriveRequest
     */
    constructionDerive(req: Req): Promise<any> {
        return this.service.constructionDerive(ConstructionDeriveRequestFromJSON(req.body)).then(ConstructionDeriveResponseToJSON);
    }

    /**
     * TransactionHash returns the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     *
     *  @param req - The request object, where the body is a ConstructionHashRequest
     */
    constructionHash(req: Req): Promise<any> {
        return this.service.constructionHash(ConstructionHashRequestFromJSON(req.body)).then(TransactionIdentifierResponseToJSON);
    }

    /**
     * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling `/construction/preprocess` in an offline environment. You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in `/construction/preprocess`. It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in `/construction/payloads`). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required.
     * Get Metadata for Transaction Construction
     *
     *  @param req - The request object, where the body is a ConstructionMetadataRequest
     */
    constructionMetadata(req: Req): Promise<any> {
        return this.service.constructionMetadata(ConstructionMetadataRequestFromJSON(req.body)).then(ConstructionMetadataResponseToJSON);
    }

    /**
     * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction. This is run as a sanity check before signing (after `/construction/payloads`) and before broadcast (after `/construction/combine`).
     * Parse a Transaction
     *
     *  @param req - The request object, where the body is a ConstructionParseRequest
     */
    constructionParse(req: Req): Promise<any> {
        return this.service.constructionParse(ConstructionParseRequestFromJSON(req.body)).then(ConstructionParseResponseToJSON);
    }

    /**
     * Payloads is called with an array of operations and the response from `/construction/metadata`. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all \"effects\" of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \"intent\" of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.
     * Generate an Unsigned Transaction and Signing Payloads
     *
     *  @param req - The request object, where the body is a ConstructionPayloadsRequest
     */
    constructionPayloads(req: Req): Promise<any> {
        return this.service.constructionPayloads(ConstructionPayloadsRequestFromJSON(req.body)).then(ConstructionPayloadsResponseToJSON);
    }

    /**
     * Preprocess is called prior to `/construction/payloads` to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce). The `options` object returned from this endpoint will be sent to the `/construction/metadata` endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the `/construction/preprocess` request (in the `metadata` field).
     * Create a Request to Fetch Metadata
     *
     *  @param req - The request object, where the body is a ConstructionPreprocessRequest
     */
    constructionPreprocess(req: Req): Promise<any> {
        return this.service
            .constructionPreprocess(ConstructionPreprocessRequestFromJSON(req.body))
            .then(ConstructionPreprocessResponseToJSON);
    }

    /**
     * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool. The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error.
     * Submit a Signed Transaction
     *
     *  @param req - The request object, where the body is a ConstructionSubmitRequest
     */
    constructionSubmit(req: Req): Promise<any> {
        return this.service.constructionSubmit(ConstructionSubmitRequestFromJSON(req.body)).then(TransactionIdentifierResponseToJSON);
    }
}

/**
 * ConstructionApi - service interface for the server side implementation.
 *
 *
 * @export
 * @interface ConstructionApiService
 */
export interface ConstructionApiService {
    /**
     * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures. The signed transaction returned from this method will be sent to the `/construction/submit` endpoint by the caller.
     * Create Network Transaction from Signatures
     *
     * requestParameters - the body of the RPC style request.
     */
    constructionCombine(requestParameters: ConstructionCombineRequest): Promise<ConstructionCombineResponse>;

    /**
     * Derive returns the AccountIdentifier associated with a public key. Blockchains that require an on-chain action to create an account should not implement this method.
     * Derive an AccountIdentifier from a PublicKey
     *
     * requestParameters - the body of the RPC style request.
     */
    constructionDerive(requestParameters: ConstructionDeriveRequest): Promise<ConstructionDeriveResponse>;

    /**
     * TransactionHash returns the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     *
     * requestParameters - the body of the RPC style request.
     */
    constructionHash(requestParameters: ConstructionHashRequest): Promise<TransactionIdentifierResponse>;

    /**
     * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling `/construction/preprocess` in an offline environment. You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in `/construction/preprocess`. It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in `/construction/payloads`). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required.
     * Get Metadata for Transaction Construction
     *
     * requestParameters - the body of the RPC style request.
     */
    constructionMetadata(requestParameters: ConstructionMetadataRequest): Promise<ConstructionMetadataResponse>;

    /**
     * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction. This is run as a sanity check before signing (after `/construction/payloads`) and before broadcast (after `/construction/combine`).
     * Parse a Transaction
     *
     * requestParameters - the body of the RPC style request.
     */
    constructionParse(requestParameters: ConstructionParseRequest): Promise<ConstructionParseResponse>;

    /**
     * Payloads is called with an array of operations and the response from `/construction/metadata`. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all \"effects\" of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \"intent\" of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.
     * Generate an Unsigned Transaction and Signing Payloads
     *
     * requestParameters - the body of the RPC style request.
     */
    constructionPayloads(requestParameters: ConstructionPayloadsRequest): Promise<ConstructionPayloadsResponse>;

    /**
     * Preprocess is called prior to `/construction/payloads` to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce). The `options` object returned from this endpoint will be sent to the `/construction/metadata` endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the `/construction/preprocess` request (in the `metadata` field).
     * Create a Request to Fetch Metadata
     *
     * requestParameters - the body of the RPC style request.
     */
    constructionPreprocess(requestParameters: ConstructionPreprocessRequest): Promise<ConstructionPreprocessResponse>;

    /**
     * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool. The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error.
     * Submit a Signed Transaction
     *
     * requestParameters - the body of the RPC style request.
     */
    constructionSubmit(requestParameters: ConstructionSubmitRequest): Promise<TransactionIdentifierResponse>;
}

/**
 * ConstructionApi - interface
 *
 * @export
 * @interface ConstructionApiInterface
 */
export interface ConstructionApiInterface {
    /**
     * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures. The signed transaction returned from this method will be sent to the `/construction/submit` endpoint by the caller.
     * @summary Create Network Transaction from Signatures
     * @param {ConstructionCombineRequest} constructionCombineRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApiInterface
     */
    constructionCombineRaw(
        requestParameters: ConstructionCombineOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionCombineResponse>>;

    /**
     * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures. The signed transaction returned from this method will be sent to the `/construction/submit` endpoint by the caller.
     * Create Network Transaction from Signatures
     */
    constructionCombine(
        requestParameters: ConstructionCombineOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionCombineResponse>;

    /**
     * Derive returns the AccountIdentifier associated with a public key. Blockchains that require an on-chain action to create an account should not implement this method.
     * @summary Derive an AccountIdentifier from a PublicKey
     * @param {ConstructionDeriveRequest} constructionDeriveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApiInterface
     */
    constructionDeriveRaw(
        requestParameters: ConstructionDeriveOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionDeriveResponse>>;

    /**
     * Derive returns the AccountIdentifier associated with a public key. Blockchains that require an on-chain action to create an account should not implement this method.
     * Derive an AccountIdentifier from a PublicKey
     */
    constructionDerive(
        requestParameters: ConstructionDeriveOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionDeriveResponse>;

    /**
     * TransactionHash returns the network-specific transaction hash for a signed transaction.
     * @summary Get the Hash of a Signed Transaction
     * @param {ConstructionHashRequest} constructionHashRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApiInterface
     */
    constructionHashRaw(
        requestParameters: ConstructionHashOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<TransactionIdentifierResponse>>;

    /**
     * TransactionHash returns the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     */
    constructionHash(
        requestParameters: ConstructionHashOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<TransactionIdentifierResponse>;

    /**
     * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling `/construction/preprocess` in an offline environment. You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in `/construction/preprocess`. It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in `/construction/payloads`). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required.
     * @summary Get Metadata for Transaction Construction
     * @param {ConstructionMetadataRequest} constructionMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApiInterface
     */
    constructionMetadataRaw(
        requestParameters: ConstructionMetadataOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionMetadataResponse>>;

    /**
     * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling `/construction/preprocess` in an offline environment. You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in `/construction/preprocess`. It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in `/construction/payloads`). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required.
     * Get Metadata for Transaction Construction
     */
    constructionMetadata(
        requestParameters: ConstructionMetadataOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionMetadataResponse>;

    /**
     * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction. This is run as a sanity check before signing (after `/construction/payloads`) and before broadcast (after `/construction/combine`).
     * @summary Parse a Transaction
     * @param {ConstructionParseRequest} constructionParseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApiInterface
     */
    constructionParseRaw(
        requestParameters: ConstructionParseOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionParseResponse>>;

    /**
     * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction. This is run as a sanity check before signing (after `/construction/payloads`) and before broadcast (after `/construction/combine`).
     * Parse a Transaction
     */
    constructionParse(
        requestParameters: ConstructionParseOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionParseResponse>;

    /**
     * Payloads is called with an array of operations and the response from `/construction/metadata`. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all \"effects\" of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \"intent\" of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.
     * @summary Generate an Unsigned Transaction and Signing Payloads
     * @param {ConstructionPayloadsRequest} constructionPayloadsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApiInterface
     */
    constructionPayloadsRaw(
        requestParameters: ConstructionPayloadsOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionPayloadsResponse>>;

    /**
     * Payloads is called with an array of operations and the response from `/construction/metadata`. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all \"effects\" of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \"intent\" of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.
     * Generate an Unsigned Transaction and Signing Payloads
     */
    constructionPayloads(
        requestParameters: ConstructionPayloadsOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionPayloadsResponse>;

    /**
     * Preprocess is called prior to `/construction/payloads` to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce). The `options` object returned from this endpoint will be sent to the `/construction/metadata` endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the `/construction/preprocess` request (in the `metadata` field).
     * @summary Create a Request to Fetch Metadata
     * @param {ConstructionPreprocessRequest} constructionPreprocessRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApiInterface
     */
    constructionPreprocessRaw(
        requestParameters: ConstructionPreprocessOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionPreprocessResponse>>;

    /**
     * Preprocess is called prior to `/construction/payloads` to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce). The `options` object returned from this endpoint will be sent to the `/construction/metadata` endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the `/construction/preprocess` request (in the `metadata` field).
     * Create a Request to Fetch Metadata
     */
    constructionPreprocess(
        requestParameters: ConstructionPreprocessOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionPreprocessResponse>;

    /**
     * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool. The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error.
     * @summary Submit a Signed Transaction
     * @param {ConstructionSubmitRequest} constructionSubmitRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApiInterface
     */
    constructionSubmitRaw(
        requestParameters: ConstructionSubmitOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<TransactionIdentifierResponse>>;

    /**
     * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool. The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error.
     * Submit a Signed Transaction
     */
    constructionSubmit(
        requestParameters: ConstructionSubmitOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<TransactionIdentifierResponse>;
}

/**
 *
 */
export class ConstructionApi extends runtime.BaseAPI implements ConstructionApiInterface {
    /**
     * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures. The signed transaction returned from this method will be sent to the `/construction/submit` endpoint by the caller.
     * Create Network Transaction from Signatures
     */
    async constructionCombineRaw(
        requestParameters: ConstructionCombineOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionCombineResponse>> {
        if (requestParameters.constructionCombineRequest === null || requestParameters.constructionCombineRequest === undefined) {
            throw new runtime.RequiredError(
                'constructionCombineRequest',
                'Required parameter requestParameters.constructionCombineRequest was null or undefined when calling constructionCombine.',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request(
            {
                path: `/construction/combine`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: ConstructionCombineRequestToJSON(requestParameters.constructionCombineRequest),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ConstructionCombineResponseFromJSON(jsonValue));
    }

    /**
     * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures. The signed transaction returned from this method will be sent to the `/construction/submit` endpoint by the caller.
     * Create Network Transaction from Signatures
     */
    async constructionCombine(
        requestParameters: ConstructionCombineOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionCombineResponse> {
        const response = await this.constructionCombineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Derive returns the AccountIdentifier associated with a public key. Blockchains that require an on-chain action to create an account should not implement this method.
     * Derive an AccountIdentifier from a PublicKey
     */
    async constructionDeriveRaw(
        requestParameters: ConstructionDeriveOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionDeriveResponse>> {
        if (requestParameters.constructionDeriveRequest === null || requestParameters.constructionDeriveRequest === undefined) {
            throw new runtime.RequiredError(
                'constructionDeriveRequest',
                'Required parameter requestParameters.constructionDeriveRequest was null or undefined when calling constructionDerive.',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request(
            {
                path: `/construction/derive`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: ConstructionDeriveRequestToJSON(requestParameters.constructionDeriveRequest),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ConstructionDeriveResponseFromJSON(jsonValue));
    }

    /**
     * Derive returns the AccountIdentifier associated with a public key. Blockchains that require an on-chain action to create an account should not implement this method.
     * Derive an AccountIdentifier from a PublicKey
     */
    async constructionDerive(
        requestParameters: ConstructionDeriveOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionDeriveResponse> {
        const response = await this.constructionDeriveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * TransactionHash returns the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     */
    async constructionHashRaw(
        requestParameters: ConstructionHashOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<TransactionIdentifierResponse>> {
        if (requestParameters.constructionHashRequest === null || requestParameters.constructionHashRequest === undefined) {
            throw new runtime.RequiredError(
                'constructionHashRequest',
                'Required parameter requestParameters.constructionHashRequest was null or undefined when calling constructionHash.',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request(
            {
                path: `/construction/hash`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: ConstructionHashRequestToJSON(requestParameters.constructionHashRequest),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionIdentifierResponseFromJSON(jsonValue));
    }

    /**
     * TransactionHash returns the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     */
    async constructionHash(
        requestParameters: ConstructionHashOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<TransactionIdentifierResponse> {
        const response = await this.constructionHashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling `/construction/preprocess` in an offline environment. You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in `/construction/preprocess`. It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in `/construction/payloads`). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required.
     * Get Metadata for Transaction Construction
     */
    async constructionMetadataRaw(
        requestParameters: ConstructionMetadataOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionMetadataResponse>> {
        if (requestParameters.constructionMetadataRequest === null || requestParameters.constructionMetadataRequest === undefined) {
            throw new runtime.RequiredError(
                'constructionMetadataRequest',
                'Required parameter requestParameters.constructionMetadataRequest was null or undefined when calling constructionMetadata.',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request(
            {
                path: `/construction/metadata`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: ConstructionMetadataRequestToJSON(requestParameters.constructionMetadataRequest),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ConstructionMetadataResponseFromJSON(jsonValue));
    }

    /**
     * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling `/construction/preprocess` in an offline environment. You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in `/construction/preprocess`. It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in `/construction/payloads`). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required.
     * Get Metadata for Transaction Construction
     */
    async constructionMetadata(
        requestParameters: ConstructionMetadataOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionMetadataResponse> {
        const response = await this.constructionMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction. This is run as a sanity check before signing (after `/construction/payloads`) and before broadcast (after `/construction/combine`).
     * Parse a Transaction
     */
    async constructionParseRaw(
        requestParameters: ConstructionParseOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionParseResponse>> {
        if (requestParameters.constructionParseRequest === null || requestParameters.constructionParseRequest === undefined) {
            throw new runtime.RequiredError(
                'constructionParseRequest',
                'Required parameter requestParameters.constructionParseRequest was null or undefined when calling constructionParse.',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request(
            {
                path: `/construction/parse`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: ConstructionParseRequestToJSON(requestParameters.constructionParseRequest),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ConstructionParseResponseFromJSON(jsonValue));
    }

    /**
     * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction. This is run as a sanity check before signing (after `/construction/payloads`) and before broadcast (after `/construction/combine`).
     * Parse a Transaction
     */
    async constructionParse(
        requestParameters: ConstructionParseOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionParseResponse> {
        const response = await this.constructionParseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Payloads is called with an array of operations and the response from `/construction/metadata`. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all \"effects\" of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \"intent\" of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.
     * Generate an Unsigned Transaction and Signing Payloads
     */
    async constructionPayloadsRaw(
        requestParameters: ConstructionPayloadsOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionPayloadsResponse>> {
        if (requestParameters.constructionPayloadsRequest === null || requestParameters.constructionPayloadsRequest === undefined) {
            throw new runtime.RequiredError(
                'constructionPayloadsRequest',
                'Required parameter requestParameters.constructionPayloadsRequest was null or undefined when calling constructionPayloads.',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request(
            {
                path: `/construction/payloads`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: ConstructionPayloadsRequestToJSON(requestParameters.constructionPayloadsRequest),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ConstructionPayloadsResponseFromJSON(jsonValue));
    }

    /**
     * Payloads is called with an array of operations and the response from `/construction/metadata`. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all \"effects\" of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \"intent\" of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.
     * Generate an Unsigned Transaction and Signing Payloads
     */
    async constructionPayloads(
        requestParameters: ConstructionPayloadsOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionPayloadsResponse> {
        const response = await this.constructionPayloadsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Preprocess is called prior to `/construction/payloads` to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce). The `options` object returned from this endpoint will be sent to the `/construction/metadata` endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the `/construction/preprocess` request (in the `metadata` field).
     * Create a Request to Fetch Metadata
     */
    async constructionPreprocessRaw(
        requestParameters: ConstructionPreprocessOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<ConstructionPreprocessResponse>> {
        if (requestParameters.constructionPreprocessRequest === null || requestParameters.constructionPreprocessRequest === undefined) {
            throw new runtime.RequiredError(
                'constructionPreprocessRequest',
                'Required parameter requestParameters.constructionPreprocessRequest was null or undefined when calling constructionPreprocess.',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request(
            {
                path: `/construction/preprocess`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: ConstructionPreprocessRequestToJSON(requestParameters.constructionPreprocessRequest),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ConstructionPreprocessResponseFromJSON(jsonValue));
    }

    /**
     * Preprocess is called prior to `/construction/payloads` to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce). The `options` object returned from this endpoint will be sent to the `/construction/metadata` endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the `/construction/preprocess` request (in the `metadata` field).
     * Create a Request to Fetch Metadata
     */
    async constructionPreprocess(
        requestParameters: ConstructionPreprocessOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<ConstructionPreprocessResponse> {
        const response = await this.constructionPreprocessRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool. The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error.
     * Submit a Signed Transaction
     */
    async constructionSubmitRaw(
        requestParameters: ConstructionSubmitOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<runtime.ApiResponse<TransactionIdentifierResponse>> {
        if (requestParameters.constructionSubmitRequest === null || requestParameters.constructionSubmitRequest === undefined) {
            throw new runtime.RequiredError(
                'constructionSubmitRequest',
                'Required parameter requestParameters.constructionSubmitRequest was null or undefined when calling constructionSubmit.',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request(
            {
                path: `/construction/submit`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: ConstructionSubmitRequestToJSON(requestParameters.constructionSubmitRequest),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionIdentifierResponseFromJSON(jsonValue));
    }

    /**
     * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool. The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error.
     * Submit a Signed Transaction
     */
    async constructionSubmit(
        requestParameters: ConstructionSubmitOperationRequest,
        initOverrides?: RequestInit,
    ): Promise<TransactionIdentifierResponse> {
        const response = await this.constructionSubmitRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
